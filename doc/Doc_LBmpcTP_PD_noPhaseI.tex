\documentclass[letter]{article}
\addtolength{\textwidth}{4cm}
\addtolength{\textheight}{3cm}
\addtolength{\hoffset}{-2.5cm}
\addtolength{\topmargin}{-1cm}
\usepackage[pdftex]{graphicx}
\usepackage[english]{babel}
\usepackage[latin9]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}		%mathematisches Menge R, N
\usepackage[usenames]{color}
%\usepackage{textcomp}
%\usepackage{latexsym}		%für Re(z) und Img(z)
%\usepackage{trfsigns}		%für Fouriertrafos
\usepackage{mathrsfs}
\usepackage[hyperindex,pdfpagelabels=true,plainpages=false]{hyperref}
\usepackage[square, comma, sort&compress, numbers]{natbib}
\usepackage{listings}
%\usepackage{pstricks}
\usepackage[numbered]{mcode}
\usepackage{url}


\date{\today}
\author{Xiaojing Zhang \\ \\
 	{\bf Documentation for \texttt{LBmpcTP} template class - Version: PD IIPM} \\
 	{\it Implementation using primal-dual infeasible interior point method (PD IIPM)} \\
 	 Department of Electrical Engineering and Computer Sciences (EECS), UC Berkeley}
\title{Learning Based MPC}

%Vorspann
\begin{document}
\pagestyle{headings}	%Beschriftungen oben
\maketitle

\begin{sffamily}		%alles Serifenlos

%\newpage

\newcommand{\sinc}{\mathrm{sinc}}
\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\section*{Introduction}
This report introduces the \texttt{LBmpcTP} template class which implements the primal-dual infeasible interior point method (\textbf{PD IIPM}) based on Mehrotra's predictor-corrector algorithm \citep{Mehrotra1992PDIPM}. Our solver is tailored to  learning-based model predictive control (LBMPC) \citep{Aswani2011LBMPC} for the special case where the costs are quadratic and all involved dynamics are linear.\\

\noindent
The report is structured as follows: First, LBMPC for the case where all dynamics are linear is introduced. Second, the interface to the \texttt{LBmpcTP} class is presented. In the third section, advanced parameters for configuration and fine-tuning are described.

\section{The Learning-Based MPC model}
We consider a special case of LBMPC \citep{Aswani2011LBMPC}, in which all dynamics are linear and the cost quadratic. Furthermore, we consider the situation where the feasible sets are convex polyhedron. \\

\noindent
This instance of LBMPC is given by the following optimization problem:
\begin{align}\label{eq: LBMPC}
	\min_{c[\cdot],\theta} \quad & (\tilde{x}[m+N|m]-x^\star[m+N|m])^T \tilde{Q}_f (\tilde{x}[m+N|m]-x^\star[m+N|m]) + \\
	&  \sum_{i=0} ^ {N-1} \{ (\tilde{x}[m+i|m]-x^\star[m+i|m])^T \tilde{Q} (\tilde{x}[m+i|m]-x^\star[m+i|m]) + \nonumber \\
	& (\check{u}[m+i|m]-u^\star[m+i|m])^T R (\check{u}[m+i|m]-u^\star[m+i|m]) \}  \nonumber \\	
		\nonumber \\		
	\text{s.t.} \quad & \tilde{x}[m|m] = \hat{x}[m],\quad \bar{x}[m|m] = \hat{x}[m] \nonumber \\
		&  \tilde{x}[m+i|m]= A \tilde{x}[m+i-1|m] + B \check{u}[m+i-1|m] + s + \mathcal{O}_m(\tilde{x}[m+i-1|m],\check{u}[m+i-1|m]), \quad \forall i \nonumber\\
		& \mathcal{O}_m(\tilde{x}[m+i-1|m],\check{u}[m+i-1|m]) = L_m \tilde{x}[m+i-1|m] + M_m \check{u}[m+i-1|m] + t_m, \quad \forall i \nonumber \\
	 &	\bar{x}[m+i|m]= A \bar{x}[m+i-1|m] + B \check{u}[m+i-1|m]+s, \quad \forall i \nonumber\\
	 & \check{u}[m+i-1|m] = K\bar{x}[m+i-1|m] + c[m+i-1|m], \quad \forall i \nonumber \\
	 & F_{\bar{x},i}\bar{x}[m+i|m] \leq f_{\bar{x},i}, \quad F_{\check{u},i}\check{u}[m+i|m] \leq f_{\check{u},i}, \quad \forall i \nonumber \\
	 & F_{x\theta}\bar{x}[m+i|m] + F_\theta \theta \leq f_{x\theta},\quad \text{for some } j\in\{1,\ldots, N\} \nonumber
\end{align}

\noindent
We assume that the conditions given in table \ref{tab: matrix assumptions} hold. \\

\begin{table}[!htdp]
\caption{We make the following assumptions for \eqref{eq: LBMPC}.}
\begin{center}
\begin{tabular}{|l|l|}\hline
 $\tilde{Q}$ & positive definite\\ \hline
 $\tilde{Q}_f$ & positive definite\\ \hline
 $R$ & positive semidefinite \\ \hline
 $F_{\bar{x},i}$ & full rank \\ \hline
 $F_{\check{u},i}$ & full rank \\ \hline
 $F_\theta$ & full rank \\ \hline
 $K$ & $A+BK$ Schur \\ \hline
\end{tabular}
\end{center}
\label{tab: matrix assumptions}
\end{table}


\noindent
For the purpose of solving this LBMPC problem, it is useful to consider the optimization problem as belonging to a general class of problems, in this case a convex quadratic program (QP):

\begin{align}\label{eq: reformulation}
	 \min_{z} \qquad & z^T H z + g^T z  \\
	  \text{s.t.} \qquad & C z = b \nonumber \\
	 & P z \leq b, \nonumber 
\end{align}

\noindent
where $z$ is the stacked vector:

\begin{equation*}
	z = \begin{pmatrix}	
		c[m]^T & \bar{x}[m+1]^T & \tilde{x}[m+1]^T & \cdots & c[m+N-1]^T & \bar{x}[m+N]^T & \tilde{x}[m+N]^T & \theta^T	\end{pmatrix}^T
\end{equation*}

\noindent
It can be shown that the above QP is convex. Furthermore, we assume that Slater's condition \citep[Ch. 2]{Borrelli2011Book} holds. Hence, the KKT-conditions for optimality are necessary and sufficient and state that for every optimal $z_{opt}$ there exists vectors $\lambda_{opt}, \nu_{opt}$ and $t_{opt}$ such that at the optimal point $(z,\lambda,\nu,t)=(z_{opt},\lambda_{opt},\nu_{opt},t_{opt})$ the following equations are satisfied \citep{Nocedal2000NumOpt}:
\begin{equation}
\label{eq: KKT}
	\mathcal{F}(z,\lambda,\nu,t) \triangleq 
	\begin{pmatrix}
		r_H \\ r_C \\ r_P \\ r_T
	\end{pmatrix} \triangleq
	\begin{pmatrix}
		2Hz + g + P^T \lambda + C^T \nu \\
		Cz - b \\
		Pz-h+t \\
		T\Lambda\mathbf{1}
	\end{pmatrix} = 0,\qquad (\lambda, t) \geq 0
\end{equation}
where $t$ is the slack variable associated with the inequality in \eqref{eq: reformulation}, $T\triangleq\text{diag}(t),\ \Lambda\triangleq\text{diag}(\lambda)$ and $\mathbf{1}$ is the all-one vector. Our PD IIPM algorithm generates sequences $(z^i,\lambda^i,\nu^i,t^i)$ with $(\lambda^i,t^i)>0$ that approach the optimality condition \eqref{eq: KKT}. \\

\noindent
Because the PD IIPM algorithm is not guaranteed to generate feasible iterates (except in the limit as the algorithm converges), a duality gap cannot be defined. Instead, the complementary measure $\mu$ is used to measure the optimality of the point $(z,\lambda,\nu,t)$:
\begin{equation}
\label{eq: dualityGap}
	\mu\triangleq \frac{\lambda^T t}{m_P},
\end{equation}
where $m_P$ is the number of inequality equations, i.e. the number of rows in the Matrix $P$.

\section{Using the \texttt{LBmpcTP} template class}
The \texttt{LBmpcTP} template class is typically called in two seperate steps:

\begin{enumerate}
	\item Definition of matrices $A,\ B,\ s,\ \tilde{Q},\ \tilde{Q}_f,\ R,\ K,\ \{F_{\bar{x},i}\}_i,\ \{f_{\bar{x},i}\}_i,\ \{F_{\check{u},i}\}_i,\ \{f_{\check{u},i}\}_i,\ F_{x\theta},\ F_\theta,\ f_{x\theta}$, scalars $n_{iter},\ \epsilon_{reg},\ \epsilon_H,\ \epsilon_C,\ \epsilon_P,\ \epsilon_\mu$ and \texttt{fileName} for binary file in MATLAB file \texttt{Init.m}. The matrices and scalars are written to a binary file, whose name is specified by \texttt{fileName} (by default \texttt{ConstrParam.bin}). The complete list of variables to be specified can be found in table \ref{tab: parameters Init.m}.
	\item A C++-file (e.g. \texttt{mainLBmpcTP.cpp}) then reads the binary file \texttt{ConstrParam.bin}.  \texttt{mainLBmpcTP.cpp} is the main function file and performs two tasks:
	\begin{enumerate}
		\item It calls the constructor of the template class in \texttt{LBmpcTP.h} and instantiates an object of this template class, e.g. \texttt{myObj}. For example: \\
		\texttt{LBmpcTP<double, \_n, \_m, \_N, \_nSt, \_nInp, \_nF\_xTheta, \_pos\_omega> myObj( fileName, verbose)}
		\item It calls the step-function \texttt{myObj.step(.)} which computes the optimal input and returns a status flag. The optimal input is stored in the public variable \texttt{u\_opt}. Each call of the step-function requires the following (updated) parameters: $L_m,\ M_m,\ t_m,\ \hat{x},\ \{x^\star[m+i]\}_i$. \\
		\texttt{status = myObj.step( Lm, Mm, tm, x\_hat, x\_star );}\\
		\texttt{u\_opt = myObj.u\_opt;}
	\end{enumerate}
\end{enumerate}

\noindent
The files can be compiled using the gcc-compiler and the following command: \newline
\texttt{g++ -I /usr/local/include/eigen3/ -O3 mainLBmpcTP.cpp -o mainLBmpcTP}. \\


\noindent
In the following sections, both files and the variables are described in more detail.
\subsection{MATLAB: \texttt{Init.m}}
In this MATLAB-file, the parameters required for the instantiation of the \texttt{LBmpcTP} object are defined. More specifically, \texttt{Init.m} consists of two parts:
\begin{itemize}
	\item User has to manually specify the parameters given in table \ref{tab: parameters Init.m}.
	\item A binary file (default: \texttt{ConstrParam.bin}) with the parameters in table \ref{tab: parameters Init.m} is created automatically by calling the MATLAB script \texttt{writeParam.m}.
\end{itemize}
In appendix \ref{app: Init.m}, a typical implementation of the \texttt{Init.m} file is shown. \\

\begin{table}[!htdp]
\caption{Key parameters which are to be defined in \texttt{Init.m}}
\begin{center}
\begin{tabular}{|l|l|l|}\hline
{\bf MATLAB variable} & description & typical range/value \\ \hline\hline

 \texttt{N} & length of MPC horizon & \\ \hline
 \texttt{m} & number of inputs & \\ \hline
 \texttt{n} & number of states & \\ \hline \hline
 
 \texttt{fileName} & name of binary file that stores the matrices and scalars defined below. \\ \hline \hline
 
 \texttt{A} & linear dynamics matrix: $\bar{x}^+ = A\bar{x}+B\check{u}+s$ & \\ \hline
 \texttt{B} & input-state dynamics matrix: $\bar{x}^+ = A\bar{x}+B\check{u}+s$ & \\ \hline
 \texttt{s} & affine offset in state dynamics:  $\bar{x}^+ = A\bar{x}+B\check{u}+s$ & \\ \hline
 \texttt{K} & feedback gain matrix, $\check{u}=K\bar{x}+c$, $A+BK$ is stable & \\ \hline \hline
  
 \texttt{Q\_tilde} & p.d. weight matrix for state & \\ \hline
 \texttt{Q\_tilde\_f} & p.d. weight matrix for final state & \\ \hline
 \texttt{R} & p.s.d. weight matrix on input & \\ \hline
 \texttt{Fx\{$i$\}} & $F_{\bar{x},i}\bar{x}[m+i|m] \leq f_{\bar{x},i}$, full-rank, $i=1,\ldots,N$ & \\ \hline
 \texttt{fx\{$i$\}} & $F_{\bar{x},i}\bar{x}[m+i|m] \leq f_{\bar{x},i}$ & \\ \hline
 \texttt{Fu\{$i$\}} & $F_{\check{u},i}\check{u}[m+i|m] \leq f_{\check{u},i}$, full-rank, $i=0,\ldots,N-1$ & \\ \hline
 \texttt{fu\{$i$\}} & $F_{\check{u},i}\check{u}[m+i|m] \leq f_{\check{u},i}$ & \\ \hline
 \texttt{F\_xTheta} & $F_{x\theta}\bar{x}[m+j|m] + F_\theta \theta \leq f_{x\theta}$ & \\ \hline
 \texttt{F\_theta} & $F_{x\theta}\bar{x}[m+j|m] + F_\theta \theta \leq f_{x\theta}$, full-rank & \\ \hline
 \texttt{f\_xTheta} & $F_{x\theta}\bar{x}[m+j|m] + F_\theta \theta \leq f_{x\theta}$ & \\ \hline \hline

 \texttt{n\_iter} & max. number of Newton steps to solve \eqref{eq: reformulation} & $[50,200]$ \\ \hline
 \texttt{reg} & regularization coefficient to render Matrix $H$ in \eqref{eq: reformulation} positive definite & $[0,0.1]$, depends on $H$ \\ \hline
 \texttt{resNorm\_H} & $\epsilon_H$, necessary stopping criteria for $\|r_H\|$, \eqref{eq: stoppingCriteria} & $0.01$ \\ \hline
 \texttt{resNorm\_C} & $\epsilon_C$, necessary stopping criteria for $\|r_C\|$, \eqref{eq: stoppingCriteria} & $0.01$ \\ \hline
 \texttt{resNorm\_P} & $\epsilon_P$, necessary stopping criteria for $\|r_P\|$, \eqref{eq: stoppingCriteria} & $0.01$ \\ \hline
 \texttt{muNorm} & $\epsilon_\mu$, necessary stopping criteria for $\mu$, \eqref{eq: stoppingCriteria} & $0.01$ \\ \hline

\end{tabular}
\end{center}
\label{tab: parameters Init.m}
\end{table}

\noindent
Remarks:
\begin{itemize}
	\item The number of state constraints is assumed to be constant, i.e. the number of rows in \texttt{Fx\{$i$\}} is constant for all $i$, and  denoted by \texttt{\_nSt}.
	\item The number of input constraints is assumed to be constant, i.e. the number of rows in \texttt{Fu\{$i$\}} is constant for all $i$, and denoted by \texttt{\_nInp}.
	\item The number of constraints involving $\theta$ in \eqref{eq: LBMPC} is assumed to be \texttt{\_nF\_xTheta}.
\end{itemize}


\subsection{C++: \texttt{mainLBmpcTP.cpp}}
This file contains the main control routine which interacts with the \texttt{LBmpcTP} template class. An example file is provided in appendix \ref{app: mainLBmpcTP.cpp}. In the following, we outline the typical steps in \texttt{mainLBmpcTP.cpp}:

\begin{enumerate}
	\item \textbf{SPECIFY parameters:} \texttt{\_N}, \texttt{\_m}, \texttt{\_n}, \texttt{\_nSt}, \texttt{\_nInp}, \texttt{\_nF\_xTheta}, \texttt{\_pos\_omega} (see table \ref{tab: instantiateLBpmcTP}).
	
		\begin{table}[!htdp]
		\caption{The following template parameters are required to instantiate a \texttt{LBmpcTP}-object.}
		\begin{center}
		\begin{tabular}{|l|l|l|}\hline
		{
 			\bf variable} & description & default \\ \hline\hline
 
			\texttt{Type} & only \texttt{double} is supported & \texttt{double} \\ \hline
 			\texttt{\_N} & length of MPC horizon & \\ \hline
 			\texttt{\_m} & number of inputs & \\ \hline
 			\texttt{\_n} & number of states & \\ \hline 
 			\texttt{\_nSt} & number of state constraints (constant over the horizon) & \\ \hline
 			\texttt{\_nInp} & number of input constraints (constant over the horizon) & \\ \hline
	 		\texttt{\_nF\_xTheta} & number of constraints involving $\theta$ in \eqref{eq: LBMPC} & \\ \hline
 			\texttt{\_pos\_Omega} & index $j$ in $F_{x\theta}\bar{x}[m+j|m] + F_\theta \theta \leq f_{x\theta}$ & \\ \hline 
		\end{tabular}
		\end{center}
		\label{tab: instantiateLBpmcTP}
		\end{table}	
	
	\item \textbf{SPECIFY binary source file name and verbose-flag:} \texttt{fileName}, \texttt{verbose}: \\
	\texttt{const char fileName[] = "ConstrParam.bin";} \\
	\texttt{bool verbose = 0;\qquad // 0 = shut up}
	
	\item Call the constructor and instantiate an object (e.g. \texttt{myObj}): \\
	\texttt{LBmpcTP<double,\_n,\_m,\_N,\_nSt,\_nInp,\_nF\_xTheta,\_pos\_omega> myObj(fileName,verbose);}
	
	\item Update the variables needed for step()-function: \texttt{Lm}, \texttt{Mm}, \texttt{tm},  \texttt{x\_hat}, \texttt{x\_star[\_N]}  (table 
\ref{tab: oracleParameters}). Note: these values are  not provided in this framework.
	
	\begin{table}[!htdp]
	\caption{These arguments must be updated before each \texttt{step()}-call.}
	\begin{center}
	\begin{tabular}{|l|l|}\hline
	{
 		\bf variable} & description \\ \hline\hline
 
		 \texttt{Lm} & oracle matrix, i.e. $\mathcal{O}_m(\tilde{x}[m+i|m],\check{u}[m+i|m]) = L_m \tilde{x}[m+i|m] + M_m \check{u}[m+i|m] + t_m$ 					 \\ \hline
 		\texttt{Mm} & oracle matrix, i.e. $\mathcal{O}_m(\tilde{x}[m+i|m],\check{u}[m+i|m]) = L_m \tilde{x}[m+i|m] + M_m \check{u}[m+i|m] + t_m$ 					 \\ \hline
 		\texttt{tm} & oracle matrix, i.e. $\mathcal{O}_m(\tilde{x}[m+i|m],\check{u}[m+i|m]) = L_m \tilde{x}[m+i|m] + M_m \check{u}[m+i|m] + t_m$				\\ \hline
 		\texttt{x\_hat} & current state estimate, i.e. $\tilde{x}[m] = \hat{x}[m],\quad \bar{x}[m] = \hat{x}[m]$ \\ \hline
 		\texttt{x\_star[\_N]} & states our system wants to track \\ \hline
	\end{tabular}
	\end{center}
	\label{tab: oracleParameters}
	\end{table}	
	
	\item Call the step-function to solve the optimization problem: \\
	\texttt{status = myObj.step( Lm, Mm, tm, x\_hat, x\_star );} \\
	The meaning of the status-flag are given in table \ref{tab: error code}
	
	\begin{table}[!htdp]
	\caption{The meaning of the status-flags returned by \texttt{step()}-function.}
	\begin{center}
	\begin{tabular}{|l|l|}\hline
	{
	 \bf status flag} & meaning  \\ \hline\hline
	 0 & success \\
	 1 & too many iterations, stopping criterion $\|r_H\| \leq \epsilon_H$ not satisfied\\
	 2 & too many iterations, stopping criterion $\|r_C\| \leq \epsilon_C$ not satisfied \\
	 3 & too many iterations, stopping criterion $\|r_P\| \leq \epsilon_P$ not satisfied \\
	 4 & too many iterations, stopping criterion $\mu \leq \epsilon_\mu$ not satisfied \\
	 5 & \texttt{nan} \\
	 6 & other error \\ \hline
	\end{tabular}
	\end{center}
	\label{tab: error code}
	\end{table}
	
	\item The optimal input can be accessed by: \texttt{u\_opt = myObj.u\_opt;}
\end{enumerate}


\noindent
It should be noticed that the parameters in the MATLAB file \texttt{Init.m} and the C++ file \texttt{mainLBmpcTP.cpp} have to be consistent with each other.



\subsection{C++ template class: \texttt{LBmpcTP.h}}
This section gives a rough overview of what happens inside the \texttt{LBmpcTP} class. Access to the class is granted through two methods, the constructor and the \texttt{step(.)} method. Details on the underlying mathematics can be found in \citep{Mehrotra1992PDIPM, Potra2000IPM, Rao98IMP2MPC, Nocedal2000NumOpt}. The constructor initializes some of the private variables as discussed in the previous sections. The \texttt{step(.)}-method performs the following tasks:
\begin{itemize}
	\item We recursively compute the sequence $\{  u^\star[m+i|m]  \}_i$ from the given desired state sequence $\{ x^\star[m+i|m] \}_i$ by solving 
	\begin{equation*}
			x^\star [m+i|m] = (A+L_m)x^\star[m+i-1|m] + (B+M_m)u^\star[m+i-1|m] + (s+t_m)
	\end{equation*}
	and taking the least-squared solution (SVD).
	\item Cast \eqref{eq: LBMPC} into \eqref{eq: reformulation}.
	\item Finally, it computes the optimal control input and stores it in the public member variable \texttt{myObj.u\_opt}.
\end{itemize}


\section{Tuning}
Some of the parameters given in Tab. \ref{tab: parameters Init.m} can be used to tweak the \texttt{LBmpcTP} template class if the algorithm does not work as desired:
\begin{itemize}
	\item The problem cannot be solved with the default parameters. It either does not converge (number of iterations exceeds \texttt{num\_iter}) or the code returns \texttt{nan}.
	\item Convergence is too slow for the desired purpose, i.e. the optimization step needs too many Newton iterations.
	\item The exact solution is not desired and an approximate solution suffices to speed up algorithm.
\end{itemize}
The goal of this section is to share some experience of how to react to certain situations and give some general advice on how to choose the parameters.\\

\noindent
Tab. \ref{tab: tuning parameters} lists the tuning parameters from Tab. \ref{tab: parameters Init.m} and describes their role and influence in greater detail.

\begin{table}[!htdp]
\caption{Tuning parameters defined in \texttt{Init.m}}
\begin{center}
\begin{tabular}{|p{3.5cm}|p{10cm}|p{3cm}|}\hline
{
	\bf tuning variable} & influence & typical range/value \\ \hline\hline

  \texttt{n\_iter} & Can be used to limit the number of Newton iterations or for early termination to  obtain an inaccurate solution of \eqref{eq: reformulation}. This can be useful if the computational time is limited & $[50,200]$ \\ \hline
 \texttt{reg} & regularization coefficient to render Matrix $H$ in \eqref{eq: reformulation} positive definite, see \eqref{eq: regularization}  & $[0,0.1]$, depends on $H$ \\ \hline
 \texttt{resNorm\_H} & $\epsilon_H$, necessary stopping criteria for $\|r_H\|$, see \eqref{eq: stoppingCriteria} & $0.01$ \\ \hline
 \texttt{resNorm\_C} & $\epsilon_C$,necessary stopping criteria for $\|r_C\|$, see \eqref{eq: stoppingCriteria} & $0.01$ \\ \hline
 \texttt{resNorm\_P} & $\epsilon_P$,necessary stopping criteria for $\|r_P\|$, see \eqref{eq: stoppingCriteria} & $0.01$ \\ \hline
 \texttt{muNorm} & $\epsilon_\mu$, necessary stopping criteria for $\mu$, see \eqref{eq: stoppingCriteria} & $0.01$ \\ \hline
\end{tabular}
\end{center}
\label{tab: tuning parameters}
\end{table}


\subsection{Compiling}
Note that in order to use (and compile) the \texttt{LBmpcTP} template library, the EIGEN\footnote{\url{http://eigen.tuxfamily.org/}} library has to be installed.\\

\noindent
Furthermore, some compilers provide the option to generate optimized executable codes. For example, the gcc compiler allows the user to add the \texttt{-O3} option which  reduces the size of the executable file and increases the performance of the generated code: \\
\noindent
\texttt{g++ -I /usr/local/include/eigen3/ -O3 mainLBmpcTP.cpp -o mainLBmpcTP}

\subsection{Stopping Criteria and Regularization}
This section addresses how and when the iterations are terminated. In this Algorithm, a simple stopping criteria suggested in \citep{Jorgensen2006, Krueth2008, Boyd2004ConvOpt} is used. It consists of the following four conditions:
\begin{align}
\label{eq: stoppingCriteria}
	\|r_H\| &\leq \epsilon_H \\
	\|r_C\| &\leq \epsilon_C	\nonumber \\
	\|r_P\| &\leq \epsilon_P	\nonumber  \\
	\mu &\leq \epsilon_\mu \nonumber 
\end{align}
Our algorithm terminates if all four conditions are satisfied. It should be mentioned in this place that the smaller we choose the various $\epsilon$ to be, the badly conditioned our problem becomes. A forteriori, this is true for $\epsilon_\mu$. Because the matrix $H$ in \eqref{eq: LBMPC} is not strictly convex, numerical issues arise as we try to push the residuals \eqref{eq: KKT} towards zero: the normal equation becomes badly conditioned, posing challenges when computing the Cholesky decomposition numerically. For that reason, we have introduced a regularization parameter $\epsilon_{reg}$ (\texttt{reg}) that regularizes our problem to:
\begin{equation}
\label{eq: regularization}
	H_{reg} = H + \epsilon_{reg}\mathbb{I},
\end{equation}
where $\mathbb{I}$ is the identity matrix.

\subsection{Troubleshooting}
In this section, some common errors are described. Possible sources for these errors are given and solutions are proposed.
\begin{enumerate}	
	\item \textbf{Many Newton steps ($\gtrapprox 200$) are required to solve \eqref{eq: reformulation}.} \\
		\emph{Solutions:}
			\begin{itemize}				
				\item Many Newton steps with tiny step sizes are perfomed. Since this is waste of computational time, the number of Newton iterations can be upperbounded by choosing a smaller \texttt{n\_iter}. Depending on the problem setup, numbers as few as $10$ iterations might be enough to produce satisfying results.
			\end{itemize}
	
	\item \textbf{Obtained result is a \texttt{nan}-vector (not a number).} \\
		\emph{Solutions:}
		\begin{itemize}
			\item This problem typically shows up after the residuals \eqref{eq: KKT} have become small, especially when $z_{opt}$ lies on some face of the feasible set. Even though positive definiteness (and hence the existence of Cholesky decomposition) is theoretically guaranteed, this might not be true from a numerical point of view. Indeed, a \texttt{nan} often suggests that some of the eigenvalues numerically approach zero, ending up dividing by zero, leading to \texttt{nan}. To solve this, the cost in \eqref{eq: reformulation} is regularized according to \eqref{eq: regularization}. Thus, choosing a larger \texttt{reg} usually avoids this problem, but may return inferior results. Alternatively, we may want to increase the different $\epsilon$ in \eqref{eq: stoppingCriteria}.
		\end{itemize}
\end{enumerate}

\subsection{Additional Remarks}
\begin{itemize}
	\item So far, the algorithm only works for a minimum prediction horizon of $3$.
	\item There are more parameters in the \texttt{LBmpcTP.h} file which can be used to improve the performance of the solver, such as how to choose the regularization and how to initialize the starting points $(z^0,\lambda^0,\nu^0,t^0)$. However, it usually suffices to tune  the parameters given in Table \eqref{tab: tuning parameters}.
	\item If the prediction horizon $N\geq50$, then some variable definitions in the class file have to be changed. More precisely, the size of some preallocated arrays of the \texttt{LLT}-class must be increased to: \texttt{L\_diag[2*\_N]}, \texttt{LOmicron\_diag[\_N+1]}, \texttt{LPi\_diag[\_N]}, \texttt{LRho\_diag[\_N]}.
	
	\item When an \texttt{LBmpcTP} object is instantiated, the class variable \texttt{z} is initialized. Between the time steps, \texttt{z} can take  the role of "warm start". However, when the \texttt{LBmpcTP} is instantiated, it set as the $0$-vector. If a priori information is available, then a more suitable \texttt{z} can be chosen.
\end{itemize}



%\newpage
%\section{Example Files}
%\subsection{\texttt{Init.m}} \label{app: Init.m}
%\lstset{language=Matlab}
%\lstinputlisting{Code/Init.m}

%\newpage
%\subsection{ \texttt{mainLBmpcTP.cpp}} \label{app: mainLBmpcTP.cpp}
%\lstset{language=C}
%\lstinputlisting{Code/mainLBmpcTP.cpp}



\end{sffamily}		%Ende alles Serifenlos

\bibliographystyle{IEEEtran}
\bibliography{bibliography}


\end{document}






